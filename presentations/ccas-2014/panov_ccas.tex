\documentclass[mathserif]{beamer}
\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{theorems}[numbered]
\usetheme{AnnArbor}
\useoutertheme{infolines}
\usecolortheme{crane}

\makeatletter
\setbeamertemplate{footline}
{
	\leavevmode%
	\hbox{%
		\begin{beamercolorbox}[wd=.333333\paperwidth,ht=2.25ex,dp=1ex,center]{author in head/foot}%
			\usebeamerfont{author in head/foot}\insertshortauthor~~\beamer@ifempty{\insertshortinstitute}{}{(\insertshortinstitute)}
		\end{beamercolorbox}%
		\begin{beamercolorbox}[wd=.333333\paperwidth,ht=2.25ex,dp=1ex,center]{title in head/foot}%
			\usebeamerfont{title in head/foot}\insertshorttitle
		\end{beamercolorbox}%
		\begin{beamercolorbox}[wd=.333333\paperwidth,ht=2.25ex,dp=1ex,right]{date in head/foot}%
			\usebeamerfont{date in head/foot}\insertshortdate{}\hspace*{2em}
			\insertframenumber{}\hspace*{2ex} 
		\end{beamercolorbox}}%
		\vskip0pt%
	}
\makeatother
	
\usepackage{cmap}	% Поддержка поиска русских слов в PDF (pdflatex)
\usepackage[T2A]{fontenc}       %поддержка кириллицы
\usepackage[cp1251]{inputenc}	% Выбор языка и кодировки
\usepackage[english, russian]{babel}
\usepackage{caption}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{subfig}

\graphicspath{{../../images/}} 			% Пути к изображениям

\DeclareMathOperator*{\argmax}{arg\,max}
\algnewcommand\And{\textbf{and}}
\makeatletter
\newenvironment<>{proofs}[1][\proofname]{%
	\par
	\def\insertproofname{#1\@addpunct{.}}%
	\usebeamertemplate{proof begin}#2}
{\usebeamertemplate{proof end}}
\makeatother

\makeatletter
\newenvironment{cenumerate}{%
	\enumerate
	\setcounter{\@enumctr}{\csname saved@\@enumctr\endcsname}%
}{%
\expandafter\xdef\csname saved@\@enumctr\endcsname{\the\value{\@enumctr}}%
\endenumerate
}
\newenvironment{cenumerate*}{%
	\enumerate
}{%
\expandafter\xdef\csname saved@\@enumctr\endcsname{\the\value{\@enumctr}}%
\endenumerate
}
\makeatother

\let\Theorem\relax
\newtheorem{Theorem}{Теорема}
\newtheorem{Pred}{Утверждение}
\let\Corollary\relax
\newtheorem{Corollary}{Следствие}
\newtheorem{Def}{Определение}
\floatname{algorithm}{Алгоритм}
\algrenewcommand\algorithmicrequire{\textbf{Вход:}}
\algrenewcommand\algorithmicensure{\textbf{Выход:}}
\algrenewcommand\algorithmicreturn{\textbf{Выход:}}

\begin{document}
	
	\title[Модель картины мира]{Исследование образной и процедурной компонент картины мира субъекта деятельности}
	\author{Александр Панов}
	\institute[ИСА РАН]{ИСА РАН\\ научный руководитель д.ф.-м.н., проф. Г.\,С.~Осипов}
	\date{18 декабря 2014 г.} 
	
	\begin{frame}
		\titlepage
	\end{frame}

	\begin{frame}
		\frametitle{Картина мира и нейрофизиология}

		\begin{figure}
			\includegraphics[width=0.33\textwidth]{ivanitsky_cyrcle}
		\end{figure}
		
		По нейрофизиологическим данным (В. Маунткасл,1981; Дж. Хокинс, 2009), в том числе в \textit{теории повторного входа} или \textit{информационного синтеза} (Д.~Эдельман, 1981; А.\,М.~Иваницкий, 1996) возникновение ощущения, т.~е. активизация некоторого элемента картины мира субъекта, происходит при замыкании контура распространения нервного возбуждения от сенсорного входа. При этом происходит наложение значения сигнала (гиппокамп) и эмоционального отношения к нему (гипоталамус) на поступившую сенсорную информацию.
	\end{frame}

	\begin{frame}
		\frametitle{Картина мира и психология}
		
		В \textit{культурно"--~историческом подходе} (А.\,Р.~Лурия, 1970; Л.\,Н.~Выготский, 1960) вводится понятие знака как основного инструмента познавательной деятельности субъекта. В \textit{теории деятельности} (А.\,Н.~Леонтьев, 1975) раскрывается структура знака и его роль в формировании не только познавательной, но и любой другой деятельности субъекта.
		\par\bigskip
		По Леонтьеву образующими картины мира, т.~е. компонентами знака, являются \textit{образ}, \textit{значение} и \textit{личностный смысл}.<<В значениях представлена преобразованная и свёрнутая в материи языка идеальная форма существования предметного мира ... раскрываемая в совокупной общественной практикой>>. Личностный смысл является <<значением"--~для"--~меня>>.

		<<Движение,~соединяющее абстрактное значение с чувственным миром,~представляет собой одно из существеннейших движений сознания>> (А.\,Н.~Леонтьев).
	\end{frame}
	
	\begin{frame}
		\frametitle{Знак "--- элемент картины мира}
		\begin{columns}
			\begin{column}{0.6\textwidth}
				\begin{figure}
					\includegraphics[width=0.7\textwidth]{sign}
				\end{figure}
			\end{column}
			\begin{column}{0.4\textwidth}
				Знак имеет следующие компоненты: 
				\begin{itemize}
					\item имя,
					\item образ, 
					\item значение и 
					\item личностный смысл.	
				\end{itemize}
			\end{column}
		\end{columns}						

	\end{frame}	
				
	\begin{frame}
		\frametitle{Предмет и цель исследования}
		
		\textbf{Предмет исследования} "--- построение моделей картины мира субъекта деятельности и некоторых когнитивных функций.
		\par\bigskip
		\textbf{Целью исследования} является разработка моделей и алгоритмов формирования пары образа и значения элемента знаковой картины мира субъекта деятельности.

		\par\bigskip
		Таким образом, в настоящей работе рассматриваются алгоритмы формирования двух основных компонент знака: образа и значения. Исследуется сходимость итерационного процесса связывания этих компонент и рассматриваются некоторые функции знаковой картины мира
	\end{frame}
	
	\begin{frame}
		\frametitle{Задачи исследования}
		В качестве модели компонент знака в работе строится специальный распознающий автомат, функционирование которого соответствует (с~некоторыми упрощениями) нейрофизиологическим данным о работе указанных участков коры головного мозга человека.
		\par\bigskip
		В работе были поставлены и решены следующие задачи:
		\begin{itemize}
			\item исследовать автоматную функцию иерархии распознающих автоматов с заданным множеством состояний, полученными в результате процесса обучения (например, по алгоритму HTM);
			\item на основе построенной модели разработать итерационный алгоритм формирования и связывания двух основных компонент знака: образа и значения;
			\item исследовать сходимость построенного итерационного алгоритма.
		\end{itemize}
	\end{frame}
	
	\begin{frame}
		\frametitle{Признаки и распознающие автоматы}
		Для уточнения постановки задачи введём следующие объекты:
		\begin{itemize}
			\item 
			$\mathcal R$ "--- совокупность распознающих автоматов или $R$-автоматов,
			\item
			$\mathcal F$ "--- совокупность допустимых признаков.
		\end{itemize}
		\par\bigskip
		Введём бинарное отношение $\dashv$, определённое на декартовом произведении $\mathcal F\times\mathcal R$, и будем читать $f_k{\dashv}R_i^j$ как <<признак $f_k$ распознаётся $R$-автоматом $R_i^j$>>. 
		\par\bigskip	
		Множество всех распознаваемых $R$-автоматом $R_i^j$ признаков будем обозначать $F_i^{*j}$, т.~е. ${\forall}f^*{\in}F_i^{*j} f^*{\dashv}R_i^j, F_i^{*j}{\subseteq}\mathcal F$.
	\end{frame}
	
	\begin{frame}
		\frametitle{Иерархия распознающих автоматов}
		\begin{figure}
			\includegraphics[width=0.5\textwidth]{rb_hierarchy}
		\end{figure}
		Представим иерархию в виде связного ориентированного ярусного граф $G_R=(V,E)$:
		\begin{itemize}
			\item 
			$V=\mathcal R$ "--- множество вершин,
			\item
			$E\subset \mathcal R\times\mathcal R$ "--- множество рёбер,
			\item 
			каждая вершина, принадлежащая $j$-ому ярусу графа $G_R$, является $R$-автоматом $R_i^j$ уровня $j$,
			\item
			каждое ребро $e=(R_{i_1}^{j_1},R_{i_2}^{j_2}){\in}E$ обозначает иерархическую связь между дочерним $R$-автоматом $R_{i_1}^{j_1}$ и $R$-автоматом "--- родителем $R_{i_2}^{j_2}$.				
		\end{itemize}
	\end{frame}
	
	\begin{frame}
		\frametitle{Входные признаки и функции распознавания}
		Введём следующие определения.
		\begin{itemize}
			\item 
			Признак $f\dashv R_k^{j-1}$ называется входным для $R$-автомата $R_i^j$, если $R_k^{j-1}$ является дочерним автоматом по отношению к $R_i^j$. Всё множество входных признаков для $R_i^j$ будем обозначать $F_i^j$.
			\item
			Для каждого признака $f^*{\in}F_i^{*j}$ введём \textit{функцию распознавания} $\hat{f}(x_1,\dots,x_q)=x^*$, где $x^*{\in}(0,1)$ "--- вес распознаваемого признака $f^*$, а $x_1,\dots,x_q{\in}(0,1)$ "--- веса признаков из множества входных признаков $F_i^j$. Всю совокупность функций распознавания для $R_i^j$ будем обозначать $\hat{F}_i^j$.
		\end{itemize}
	\end{frame}
	
	\begin{frame}
		\frametitle{Задача исследования образной компоненты}
		Таким образом задача состоит в следующем:
		\begin{itemize}
			\item построить алгоритм вычисления автоматной функции распознающего автомата,
			\item построить четыре типа операторов распознавания (два статических для начального и промежуточного моментов времени, динамический и иерархический),
			\item на основе этих операторов исследовать автоматную функцию и
			\item доказать теоремы о корректности линейных замыканий построенных операторов.
		\end{itemize}
	\end{frame}
	
	\begin{frame}[t]
		\frametitle{Динамика распознающего автомата}

		\vspace*{-0.5cm}
		\begin{minipage}[t]{\textwidth}
			\begin{figure}[t]
				\includegraphics[width=\textwidth]{rb_cycle}
			\end{figure}
		\end{minipage}

		\begin{itemize}
			\item вектор $\bar{x}_i^j(t)$ длины $l_i^j$ "--- входной сигнал (вектор весов входных признаков), 
			\item вектор $\bar{x}_i^{*j}(t)$ длины $l_i^j$ "--- выходной сигнал (вектор весов распознаваемых признаков), 
			\item вектор $\hat{x}_i^{j+1}(t)$ длины $q_i^{j+1}$ "--- управляющий вектор, задающий начальное состояние в моменты времени $0,h_i^j,2h_i^j,\dots$,
			\item вектор $\hat{x}_i^j(t)$ длины $q_i^j$ "--- вектор состояния (вектор ожиданий входных признаков в следующий момент времени),
			\item $h_i^j$ "--- глубина памяти $R$-автомата $R_i^j$.
		\end{itemize}

	\end{frame}
	
	
	\begin{frame}
		\frametitle{Входы и выходы распознающего автомата}
		
		\begin{minipage}[t]{\textwidth}
			\begin{figure}[t]
				\includegraphics[width=\textwidth]{rb_io}
			\end{figure}
		\end{minipage}
	\end{frame}

	\begin{frame}
		\frametitle{Матрица предсказаний}	
		Для определения состояния $R$-автомата и его автоматной функции, поставим каждой функции распознавания $\hat{f}_k$ из множества $\hat{F}_i^j$ в соответствие набор булевых матриц предсказания $Z_k=\{Z_1^k,…,Z_m^k\}$ размерности $q_i^j\times h_i^j$. Тогда
		\begin{itemize}
			\item столбец $\bar{z}_u^r=(z_{u1}^k,…,z_{uq}^k)$ матрицы $Z_r^k$ "--- это вектор предсказания входных признаков из множества $F_i^j$ в момент времени $\tau_s+u$, $z_{uv}^k\in\{0,1\}$,
			\item матрица $Z_r^k$ задаёт последовательность битовых векторов, наличие бита в котором свидетельствует о присутствии распознаваемого функцией $\hat{f}_k$ признака,
			\item $\mathcal{Z}_i^j$ "--- множество всех матриц предсказания $R$-автомата $R_i^j$.
		\end{itemize}
	\end{frame}	
		
	\begin{frame}
		\frametitle{Входные и выходные функции}	
		Таким образом, $R$-автомат $R_i^j$ является бесконечным автоматом Миля с переменной структурой и конечной памятью и определяется следующим набором $R_i^j=<X_i^j\times \hat{X}_i^{j+1}, 2^{\mathcal Z_i^j}, X_i^{*j}\times \hat{X}_i^j,\varphi_i^j,\vec\eta_i^j>$, где
		\begin{itemize}
			\item $X_i^j$ "--- множество входных сигналов, 
			\item $X_i^{*j}$ "--- множество выходных сигналов, 
			\item $\hat{X}_i^{j+1}$ "--- множество управляющих сигналов с верхнего уровня иерархии,
			\item $\hat{X}_i^j$ "--- множество управляющих сигналов на нижний уровень иерархии,
			\item $2^{\mathcal Z_i^j}$ "--- множество состояний (множество подмножеств множества матриц предсказания),
			\item $\varphi_i^j:X_i^j\times \hat{X}_i^{j+1}\to 2^{\mathcal Z_i^j}$ "--- функция переходов,
			\item $\vec\eta_i^j:2^{\mathcal Z_i^j} \to X_i^{*j}\times \hat{X}_i^j$ "--- вектор"--~функция выходов.
		\end{itemize}
	\end{frame}	
	
	\begin{frame}
		\frametitle{Алгоритм $\mathfrak A_{th}$ функционирования $R$-автомата}
				
		\par\bigskip
		В работе построен пороговый алгоритм $\mathfrak A_{th}(c_1,c_2)$ вычисления функции переходов $\varphi_i^j$ и выходной функции $\vec\eta_i^j$ по начальному моменту времени $\tau_s$, управляющему воздействию $\hat x_i^{j+1}(\tau_s)$ и входному воздействию $\omega_i^j$. 
		
		\par\bigskip
		Для исследования автоматной функции на основании разработанного алгоритма ниже будут построены 4 типа операторов распознавания, сформулированы задачи классификации и доказаны теоремы корректности линейных замыканий множеств этих операторов.
	\end{frame}

	\begin{frame}
		\frametitle{Статический оператор распознавания}
		Зафиксируем момент времени $t$, равный началу некоторого $s$-го вычислительного цикла $\tau_s$, т.~е. рассмотрим первый этап алгоритма $\mathfrak A_{th}$ "--- задание начального состояния $R$-автомата.
		\par\bigskip
		В этом случае, $R$-автомат $R_i^j$ можно рассматривать как статический оператор распознавания $R_i^j(\hat{x}_i^{j+1},\mathcal{Z}_i^j,\bar{x}_i^j)=\bar{x}_i^{*j}$.
	\end{frame}
		
	\begin{frame}
		\frametitle{Задача классификации в статическом случае}
		Пусть
		\begin{itemize}
			\item $\mathcal Q$ "--- совокупность задач классификации,
			\item $\mathcal A$ "--- множество алгоритмов, переводящих пары $(\hat{x},\bar{x})$ в вектора $\bar{\beta}$, составленные из элементов $0,1,\Delta:A(\hat{x},\bar{x})=\bar{\beta}$.
		\end{itemize}
		\par\bigskip
		\begin{columns}
			\begin{column}{0.5\textwidth}
				Задача $Q(\hat{x},\bar{x},\bar\alpha)\in\mathcal Q$ состоит в построении алгоритма, вычисляющего по поступившему вектору ожиданий $\hat{x}$ и входному вектору $\bar{x}$ значения информационного вектора $\bar\alpha=(\alpha_1,\dots,\alpha_l), \alpha_i\in\{0,1\}$ присутствия признаков $f_1^*,…,f_l^*$. 
			\end{column}
			\begin{column}{0.5\textwidth}
				\begin{figure}[t]
					\includegraphics[width=1.0\linewidth,page=1]{rb_correct}
				\end{figure}
			\end{column}	
		\end{columns}
	\end{frame}
	
	\begin{frame}
		\frametitle{Свойство корректности алгоритма}
		\begin{Def}
			Алгоритм $A$ называется корректным для задачи $Q$, если выполнено равенство
			$$
			A(\hat{x},\bar{x})=\bar{\alpha}.
			$$
			Алгоритм $A$, не являющийся корректным для $Q$, называется некорректным.
		\end{Def}
		\par\bigskip		
		Далее будем считать, что множество $\mathcal A$ является совокупностью, вообще говоря, некорректных алгоритмов.
	\end{frame}
	
	\begin{frame}
		\frametitle{Разложение алгоритма классификации}
		\begin{Pred}[аналог теоремы Ю.\,И.~Журавлёва о введении пространства оценок]\label{st:decompositon}
			Каждый алгоритм $A\in\mathcal A$ представим как последовательность выполнения алгоритмов $R$ и $C$, где $R(\hat{x},\bar{x})=\bar{x}^*$, $\bar{x}^*$ "--- вектор действительных чисел, $C(\bar{x}^*)=\bar{\beta}$, $\beta_i\in\{0,1,\Delta\}$.
		\end{Pred}
		\par\bigskip
		\begin{itemize}
			\item $R$ "--- оператор распознавания,
			\item $C$ "--- решающее правило.
		\end{itemize}
	\end{frame}
	
	\begin{frame}
		\frametitle{Решающее правило и операции над алгоритмами}
		\begin{Def}
			Решающее правило $C^*$ называется корректным на множестве входных векторов $X$, если для всякого вектора $\bar{x}$ из $X$ существует хотя бы один числовой вектор $\bar{x}^*$ такой, что $C^*(\bar{x}^*)=\bar{\alpha}$, где $\bar{\alpha}$ "--- информационный вектор входного вектора $\bar{x}$.
		\end{Def}
		В множестве операторов $\mathcal R$ введём операции умножения на скаляр, сложения и умножения. Пусть $r'$ "--- скаляр, $R',R''\in\mathcal R$. Определим операторы $r'{\cdot}R'$, $R'+R''$ и $R{\cdot}R''$ следующим образом:
		\begin{equation}
			\label{eq:oper_scalar}
			r'{\cdot}R'=(r'{\cdot}{x_1^*}',\dots,r'{\cdot}{x_l^*}'),
		\end{equation}
		\begin{equation}
			\label{eq:oper_sum}
			R'+R''=({x_1^*}'+{x_1^*}'',\dots,{x_1^*}'+{x_l^*}''),
		\end{equation}
		\begin{equation}
			\label{eq:oper_mult}
			R'{\cdot}R''=({x_1^*}'{\cdot}{x_1^*}'',\dots,{x_1^*}'{\cdot}{x_l^*}'').
		\end{equation}
	\end{frame}
	
	\begin{frame}
		\frametitle{Замыкание множества алгоритмов}
		\begin{Pred}
			Замыкание $L(\mathcal R)$ множества $\mathcal R$ относительно операций \eqref{eq:oper_scalar} и \eqref{eq:oper_sum} является векторным пространством.
		\end{Pred}
		\begin{Pred}
			Замыкание $\mathfrak U(\mathcal R)$ множества $\mathcal R$ относительно операций \eqref{eq:oper_scalar}, \eqref{eq:oper_sum} и \eqref{eq:oper_mult} является ассоциативной линейной алгеброй с коммутативным умножением.
		\end{Pred}
		\begin{Def}
			Множества $L(\mathcal A)$ и $\mathfrak U(\mathcal A)$ алгоритмов $A=R{\cdot}C^*$ таких, что $R{\in}L(\mathcal R)$ и $R\in\mathfrak U(\mathcal R)$, называются линейными и алгебраическими замыканиями множества $\mathcal A$ соответственно.
		\end{Def}
	\end{frame}
	
	\begin{frame}
		\frametitle{Свойство полноты задачи}
		Зафиксируем пару $(\hat{x},\bar{x})$ управляющего вектора и входного вектора. Будем рассматривать задачи $Q(\hat{x},\bar{x})$, обладающие следующим свойством относительно множества операторов распознавания $\mathcal{R}$.
		
		\begin{Def}
			Если множество векторов $\{R(\hat{x},\bar{x})|R\in\mathcal R\}$ содержит базис в пространстве числовых векторов длины $l$, то задача $Q(\hat{x},\bar{x},\bar{\alpha})$ называется полной относительно $\mathcal{R}$.
		\end{Def}
	\end{frame}
	
	\begin{frame}
		\frametitle{Связь свойств полноты и корректности}
		Имеет место следующее утверждение.
		\par\bigskip
		\begin{Pred}[аналог теоремы Журавлёва о корректности линейного замыкания]\label{st:correctness}
			Если множество задач $\mathcal Q$ состоит лишь из задач, полных относительно $\mathcal R$, то линейное замыкание $L(\{R{\cdot}C^*|R\in\mathcal R\})$ ($C^*$ "--- произвольное фиксированное корректное решающее правило) является корректным относительно $\mathcal Q$.
		\end{Pred}
	\end{frame}
	
	\begin{frame}
		\frametitle{Теорема корректности в статическом случае}
		Будем рассматривать только такие задачи $Q(\hat{x},\bar{x},\bar{\alpha})$, для которых удовлетворяется следующее условие: ${\exists}k$ такое, что $x_k$ является $k$-ым элементом вектора $\bar{x}$ и $x_k>1/2$. 
		\par\bigskip
		В работе доказано следующее утверждение.
		\begin{Theorem}
			\label{th:correctness}
			Линейное замыкание $L(\mathcal A)$ семейства алгоритмов $\mathcal A=\{R\cdot C^*|R\in\mathcal R\}$ с произвольным корректным решающим правилом $C^*$ и операторами распознавания $\mathcal R$, определёнными алгоритмом $\mathfrak{A}_{th}$, является корректным на $\mathcal Q$.
		\end{Theorem}
	\end{frame}
	
	\begin{frame}
		\frametitle{Операторы распознавания $R^t$}
		Пусть $\tau_s<t<\tau_s+h_i^j$, тогда операторы распознавания примут вид $R_i^j(\hat{x}_i^j(t), \mathcal{Z}_i^j, \bar{x}_i^j(t))$, кратко $R^t$. 
		\par\bigskip
		\begin{columns}
			\begin{column}{0.5\textwidth}		
				Для этих операторов постановка задачи распознавания выглядит таким же образом как и для операторов $R$, формулировки определений полноты и корректности идентичны. 
				\par\bigskip
				Теорема о корректности линейного замыкания $L(\{R^t\cdot{C^*}|R^t\in\mathcal R^t\})$ доказывается аналогично.
			\end{column}
			\begin{column}{0.5\textwidth}
				\begin{figure}[t]
					\includegraphics[width=1.0\linewidth,page=2]{rb_correct}
				\end{figure}
			\end{column}			
		\end{columns}
	\end{frame}
	
	\begin{frame}
		\frametitle{Динамические операторы распознавания}
		Будем фиксировать не конкретный момент времени $t$, а полуинтервал ${\Delta}t=[\tau_s,\tau_s+h_i^j)$. 
		\par\bigskip
		\begin{columns}
			\begin{column}{0.5\textwidth}
				В этом случае $R$-автомат $R_i^j$ можно рассматривать как \textit{динамический оператор распознавания} $\hat{R}_i^j(\hat{x}_i^{j+1}(\tau_s), \mathcal{Z}_i^j, \omega_{i\Delta{t}}^j)=\gamma_{i\Delta{t}}^j$
				\begin{itemize}
					\item принимающий  функцию входного воздействия $\omega_i^j$ и 
					\item выдающий функцию выходной величины $\gamma_i^j$. 
				\end{itemize}
			\end{column}
			\begin{column}{0.5\textwidth}
				\begin{figure}[t]
					\includegraphics[width=1.0\linewidth,page=3]{rb_correct}
				\end{figure}
			\end{column}
		\end{columns}
	\end{frame}
	
	\begin{frame}
		\frametitle{Задача классификации в динамическом случае}
		Задача $\hat{Q}(\hat{x}, \omega_{{\Delta}t}, \bar{\alpha})$ состоит в построении алгоритма $\hat A$, вычисляющего по поступившему начальному (управляющему) вектору ожиданий $\hat{x}$ и матрице входных воздействий $\omega_{{\Delta}t}$  последовательность векторов $\beta_{\Delta{t}}$, монотонно сходящуюся к информационному вектору $\bar{\alpha}$. 
		\par\bigskip
		Искомый оператор распознавания $\hat{R}$ должен выдавать весовую матрицу распознаваемых признаков $\gamma_{\Delta{t}}$, столбцы которой должны сходиться (с учётом корректного решающего правила) к информационному вектору: $\lim_{t\to\tau_s+h}\bar{x}^*(t)=\bar{\alpha}$. 
	\end{frame}
	
	\begin{frame}
		\frametitle{Свойство корректности алгоритма в динамическом случае}
		\begin{Def}
			Алгоритм $\hat A(\hat{x},\bar{x})=\beta_{\Delta{t}}=(\bar{\beta}_1,\dots,\bar{\beta}_h)$ называется корректным для задачи $\hat{Q}$, если выполнено условие
			$$
			\|\bar{\beta}_1-\bar{\alpha}\|\geqslant\|\bar{\beta}_2-\bar{\alpha}\|\geqslant\dots\geqslant\|\bar{\beta}_h-\bar{\alpha}\|,
			$$
			причём $\|\bar{\beta}_h-\bar{\alpha}\|=0$. $\|\bar{\beta}_i-\bar{\alpha}\|=\sum_j{(\beta_{ij}-\alpha_j)}$, где $\beta_{ij}-\alpha_j=0$, если $\beta_{ij}=\alpha_j$, $\beta_{ij}-\alpha_j=\frac{1}{2}$, если $\beta_{ij}=\Delta$, и $\beta_{ij}-\alpha_j=0$ иначе. Алгоритм $\hat A$, не являющийся корректным для $\hat{Q}$, называется некорректным.
		\end{Def}
	\end{frame}
	
	\begin{frame}
		\frametitle{Разложимость алгоритма в динамическом случае}
		\begin{Pred}\label{st:decompositon_dyn}
			Каждый алгоритм $\hat{ A}\in\hat{\mathcal{A}}$ представим как последовательность выполнения алгоритмов $\hat{R}$ и $\hat{C}$, где $\hat{R}(\hat{x}, \mathcal{Z}, \omega_{\Delta{t}})=\gamma_{\Delta{t}}$, $\gamma_{\Delta{t}}$ "--- матрица действительных чисел, $\hat{C}(\gamma_{\Delta{t}})=\beta_{\Delta{t}}$, $\beta_{\Delta{t}}$ "--- матрица значений $\beta_{ij}\in\{0,1,\Delta\}$.
		\end{Pred}
	\end{frame}
	
	\begin{frame}
		\frametitle{Корректное решающее правило}
		Корректное решающее правило $\hat{C}^*$ для матрицы $\gamma_{\Delta{t}}$ определяется через набор корректных правил для векторов $(C_1^*, \dots, C_h^*)$ таких, что 
		$$
		\|C_1^*(\bar{x}^*(\tau_s))-\bar{\alpha}\|\geqslant\|C_2^*(\bar{x}^*(\tau_s+1))-\bar{\alpha}\|\geqslant\dots\geqslant
		$$
		$$
		\geqslant\|C_h^*(\bar{x}^*(\tau_s+h-1))-\bar{\alpha}\|,
		$$ 
		причём последняя норма равна нулю. В простейшем случае $\forall{i}$ $C_i^*(\bar{x}^*(\tau_s+i))=\bar{\alpha}$. 
		\par\bigskip
		Аналогично статическому случаю вводятся определения линейного $L(\hat{\mathcal R})$ и алгебраического $\mathfrak U(\hat{\mathcal R})$ замыкания над множеством $\hat{\mathcal R}$. 
	\end{frame}
	
	\begin{frame}
		\frametitle{Основная теорема корректности в динамическом случае}
		Зафиксируем начальный вектор ожиданий $\hat{x}$ и последовательность входных векторов $\omega_{\Delta{t}}$. 
		\par\bigskip
		Если, как и в статическом случае, будем рассматривать только такие задачи $\hat{Q}(\hat{x},\omega_{\Delta{t}},\bar{\alpha})$, для которых в матрице $\omega_{\Delta{t}}$ в каждом столбце с номером $s$ ${\exists}k$ такое, что $x_{sk}$ является $k$-ым элементом вектора $\bar{x}(\tau_s+s)$ и $x_{sk}>1/2$, то можно сформулировать следующую теорему.
		\par\bigskip
		В работе доказано следующее утверждение.
		\begin{Theorem}\label{th:dyn_correct}
			Линейное замыкание $L(\hat{\mathcal A})$ семейства алгоритмов $\hat{\mathcal A}=\{\hat{R}{\cdot}\hat{C}^*|\hat R\in\hat{\mathcal R}\}$ с произвольным корректным решающим правилом $\hat{C}^*$ и операторами распознавания $\hat{\mathcal R}$, определёнными алгоритмом $\mathfrak{A}_{th}$, является корректным на $\hat{\mathcal Q}$.
		\end{Theorem}
	\end{frame}
	
	\begin{frame}
		\frametitle{Иерархический оператор распознавания}
		\begin{columns}
			\begin{column}{0.5\textwidth}
				Рассмотрим пример из двухуровневой иерархии, на каждом уровне которой находится по~одному оператору: статический $R_{i_1}^{j+1}(\hat x _{i_1}^{j+2},\bar x_{i_1}^{j+1}(\tau_s),\bar\alpha_{i_1}^{j+1})$ на верхнем уровне и динамический $\hat R_{i_2}^j(\hat x _{i_2}^{j+1},\omega_{i_2\Delta t}^j,\bar\alpha_{i_2}^j)$ "--- на нижнем.
			\end{column}
			\begin{column}{0.5\textwidth}
				\begin{figure}[t]
					\includegraphics[width=0.9\linewidth,page=4]{rb_correct}
				\end{figure}
			\end{column}
		\end{columns}
		
		\par\bigskip
		Эту иерархию можно рассматривать как \textit{иерархический оператор распознавания} $\hat R_{e,j}^2(\hat x_{i_1}^{j+1}(\tau_s),\mathcal Z_{i_1}^{j+1},\mathcal Z_{i_2}^j,\omega_{i_2\Delta t}^j)=\bar x_{i_1}^{*j+1}$.
	\end{frame}	
	
	\begin{frame}
		\frametitle{Задача классификации в случае двухуровневой иерархии}
		Задача $\hat Q_{e,j}^2(\hat x_{i_1}^{j+2},\omega_{i_2\Delta t}^j,\bar\alpha_{i_1}^{j+1})$ состоит в построении алгоритма $\hat A_e$, вычисляющего по поступившему начальному вектору ожиданий $\hat x_{i_1}^{j+2}$ и матрице входных воздействий $\omega_{i_2\Delta t}^j$ значения информационного вектора $\bar\alpha_{i_1}^{j+1}$.
	\end{frame}	
	
	\begin{frame}
		\frametitle{Основная теорема корректности в иерархическом случае}
		Зафиксируем начальный вектор ожиданий $\hat x_{i_1}^{j+2}$ и последовательность входных векторов $\omega_{i_2\Delta{t}}^j$. Если рассматривать только такие задачи $\hat Q_{e,j}^2(\hat x_{i_1}^{j+2},\omega_{i_2\Delta{t}}^j,\bar\alpha_{i_1}^{j+1})$, для которых в матрице $\omega_{i_2\Delta{t}}^j$ в каждом столбце с номером $s$ ${\exists}k$ такое, что $x_{sk}$ является $k$-ым элементом вектора $\bar x_{i_2}^j(\tau_s+s)$ и $x_{sk}>1/2$, то можно сформулировать следующую теорему.
		\par\bigskip
		В работе доказано следующее утверждение.
		\begin{Theorem}\label{th:hier_correct}
			Линейное замыкание $L(\hat{\mathcal A_e})$ семейства алгоритмов $\hat{\mathcal A}_e=\{\hat R_{e,j}^2\cdot\hat C_e^*|\hat R_{e,j}^2\in\hat{\mathcal R}_{e,j}^2\}$ с произвольным корректным решающим правилом $\hat C_e^*$ и операторами распознавания $\hat{\mathcal R}_{e,j}^2$, определёнными алгоритмом $\mathfrak A_{th}$, является корректным на~множестве задач $\hat{\mathcal Q}_{e,j}^2$.
		\end{Theorem}
	\end{frame}
	
	\begin{frame}
		\frametitle{Формирование пары <<образ "--- значение>>}
			Следующая задача заключается в рассмотрении формирования пары <<образ "--- значение>> элемента картины мира субъекта под управлением некоторого значения.
			\par\bigskip
			Уточним эту постановку задачи.
	\end{frame}
	
	\begin{frame}
		\frametitle{Отношения иерархичности признаков}
		Введём семейство бинарных отношений $\{\sqsubset,\sqsubset^1,\sqsubset^2,\dots\}$, определённых на декартовом произведении $\mathcal F\times\mathcal F$. 
		\par\bigskip
		Признак $f_1$ является дочерним по отношению к признаку $f_2$: $(f_1,f_2 )\in\sqsubset$ или $f_1\sqsubset f_2$, в том случае, если $f_1\dashv R_1^j, f_2\dashv R_2^{j+1}$, $R_2^{j+1}$ "--- родительский $R$-автомат по отношению к $R_1^j$ и в множестве матриц предсказания $\mathcal Z_2$ признака $f_2$ существует как минимум одна матрица $Z_r^2$, содержащая некоторый столбец $\bar z_u^r$ с элементом $z_{uv}^r\not=0$, где $v$ "--- индекс признака $f_1$ во входном векторе для $R$-автомата $R_2^{j+1}$.
	\end{frame}
	
	\begin{frame}
		\frametitle{Отношения иерархичности признаков}		
		Пара признаков $(f_1,f_2)\in\sqsubset^t$ или $f_1\sqsubset^t f_2$, где $t\in\{1,2,\dots\}$, если $f_1\dashv R_1^j, f_2\dashv R_2^{j+1}$, $R_2^{j+1}$ "--- родительский $R$-автомат по отношению к $R_1^j$ и в множестве матриц предсказания $\mathcal Z_2$ признака $f_2$ существует хотя бы одна матрица $Z_r^2$, содержащая $t$–ый столбец $\bar z_t^r$ с элементом $z_{tv}^r\not=0$, где $v$ "--- индекс признака $f_1$ во входном векторе для $R$-автомата $R_2^{j+1}$.
		\par\bigskip
		Каждый элемент вектора"--~столбца соответствует определённому признаку из входного множества признаков $R$-автомата, что означает задание типа для каждого элемента вектора-столбца. Будем обозначать тип $k$-го элемента вектора-столбца $R$-автомата $R_i^j$ как $f_i^j(k)\in F_i^j$, $k\in(1,q_i^j)$. 
	\end{frame}
	
	\begin{frame}
		\frametitle{Признаки <<условие>> и <<эффект>>}
		Значение будем рассматривать как множество правил, каждое из которых соответствует некоторому действию. Правило для простоты будем представлять в виде пары <<условия "--- эффект действия>> так,~как это принято в искусственном интеллекте. 
		\par\bigskip
		Введём два выделенных признака: $f_c$ является меткой условия, а $f_e$ "--- меткой эффекта. Пусть некоторый $R$-автомат, например $R_0^1$, распознает оба этих признака.
		\par\bigskip
		\begin{Def}
			Признаки, которые распознаются $R$-автоматами, выступающими родительскими по отношению к $R$-автомату $R_0^1$, будем называть процедурными признаками, остальные "--- объектными признаками.
		\end{Def}
	\end{frame}
	
	\begin{frame}
		\frametitle{Столбцы условий и эффектов}
		\begin{Def}
			Столбцы матрицы предсказания $Z$, в которых соответствующий признаку $f_e$ элемент вектора не нулевой, будем называть столбцами эффектов, а те столбцы матрицы предсказания $Z$, в которых не равен нулю элемент вектора, соответствующий признаку $f_c$ -- столбцами условий. 
		\end{Def}
		\par\bigskip
		Пополним семейство отношений $\{\sqsubset,\sqsubset^1,\sqsubset^2,\dots\}$ двумя отношениями: $\sqsubset^c$ и $\sqsubset^e$, принадлежность к которым пары признаков $(f_1,f_2)$ свидетельствует о том, что признак $f_1$ присутствует соответственно в столбце условий и эффектов как минимум в одной матрице предсказания процедурного признака $f_2$.
	\end{frame}
	
	\begin{frame}
		\frametitle{Образ знака}
		\begin{Def}
			Если $f_1$ "--- признак, обозначающий знак $s_1$, то подмножество $\tilde p(f_1)$ множества $\mathcal F$ таких признаков, что $\forall f_i\in\tilde p(f_1) f_i\sqsubset f_1$, будем называть образом знака $s_1$ (признака $f_1$).
		\end{Def}
		
		На множестве всех образов $\tilde P$ введём метрику $\rho_p(\tilde p(f_1),\tilde p(f_2))$, вычисляемую по следующему правилу:
		\begin{itemize}
			\item если $f_1$ и $f_2$ распознаются разными$R$-автоматами, т.е. $f_1\dashv R_1^j, f_2\dashv R_2^i$, то $\rho_p(\tilde p(f_1),\tilde p(f_2))=\infty$,
			\item если $f_1$ и $f_2$ распознаются одним и тем же $R$-автоматом $R_1^j$ со множеством входных признаков $F_1^j$ мощности $q$ и характерным временем $h$, то
			\begin{equation}
			\rho_p(\tilde p(f_1),\tilde p(f_2))=\min\limits_{\substack{Z_r^1\in Z_1\\Z_s^2\in Z_2}}\frac{1}{q\cdot h}\sum\limits_{u=1}^h\|\bar z_u^r-\bar z_u^s\|.
			\end{equation} 
		\end{itemize}
		
	\end{frame}
	
	\begin{frame}
		\frametitle{Значение знака}
		\begin{Def}
			Если $f_1$ "--- признак, обозначающий знак $s_1$, $f_2$ "--- процедурный признак и $f_1\sqsubset^c f_2$, то будем называть $f_2$ значением знака $s_1$ (признака $f_1$). Множество всех значений признака $f_1$ будем обозначать $\tilde m(f_1)$.
		\end{Def}
		
		На множестве всех значений $\tilde M$ введём метрику $\rho_m(\tilde m(f_1),\tilde m(f_2))$ следующим образом:
		\begin{equation}
		\rho_m(\tilde m_1(f_1),\tilde m_2(f_2 ))=\min\limits_{\substack{f_i\in\tilde m(f_1 )\\f_j\in\tilde m(f_2 )}}\rho_p(\tilde p(f_i ),\tilde p(f_j )).
		\end{equation}
	\end{frame}
	
	\begin{frame}
		\frametitle{Процедурный признак как правило}
		Любой элементарный процедурный признак $f_p$, распознаваемый $R$-автоматом $R_i^j$, можно представить в виде правила $r_p=<F_C(f_p),F_A(f_p),F_D(f_p)>$, в котором:
		\begin{itemize}
			\item $F_C (f_p )\subseteq F_i^j$ "--- множество признаков "--- условий правила: $\forall f\in F_C(f_p)$ $f\sqsubset^c f_p$;
			\item $F_A(f_p)\subseteq F_i^j$ "--- множество добавляемых правилом признаков: $\forall f\in F_A(f_p)$ $f\sqsubset^e f_p,f\notin F_C$;
			\item $F_D(f_p)\subseteq F_i^j$ "--- множество удаляемых правилом признаков: $\forall f\in F_D(f_p)$ $f\notin F_A,f\in F_C$.
		\end{itemize}
	\end{frame}
	
	\begin{frame}
		\frametitle{Опыт наблюдения}
		У субъекта имеется опыт наблюдения, который выражается в виде отношения $\Psi_p^m$: $\Psi_p^m(\tilde p)=\tilde m$, в том случае, если $\tilde p\in\tilde P$ является образом некоторого знака $s$, а $\tilde m\in\tilde M$ -- значением того же знака $s$.
		\par\bigskip
		Построен итерационный алгоритм $\mathfrak A_{pm}$ доопределения функции $\Psi_p^m$, который обеспечивает формирование такого образа из множества признаков $\hat F$, при котором формируемое значение сходится к заданному значению $\tilde m^0=\{f_p\}$. Полученные образ и значение служат основной для образования нового знака.
	\end{frame}
	
	\begin{frame}
		\frametitle{Теорема корректности алгоритма $\mathfrak A_{pm}$}
		Имеет место следующее утверждение.
		\par\bigskip
		\begin{Theorem}
			Алгоритм $\mathfrak A_{pm}$ корректен, т.~е. последовательность значений $\langle\tilde m^{*(0)},\tilde m^{*(1)},\dots\rangle$, которая строится с помощью алгоритма $\mathfrak A_{pm}$ для  значения $\tilde m^0$, полученного из внешней среды, сходится к $\tilde m^0$.
		\end{Theorem}
	\end{frame}
	
	\begin{frame}
		\frametitle{Результаты}
		\begin{enumerate}
			\item Построена модель компонент знака "--- элемента картины мира субъекта деятельности.
			\item Построены четыре типа операторов распознавания (два статических оператора, динамический и иерархический операторы) в терминах алгебраической теории для образной компоненты знака.
			\item Доказаны теоремы корректности линейных замыканий множеств построенных в работе операторов распознавания.
			\item Построен итерационный алгоритм формирования и связывания двух компонент знака: образа и значения.
			\item Исследована сходимость итерационного алгоритма формирования и связывания двух компонент знака.
		\end{enumerate}
	\end{frame}
			
	\begin{frame}
		\centering
		\Huge
		Спасибо за внимание!
		\normalsize
		\par\bigskip
		\par\bigskip
		ИСА РАН, лаб. <<Динамические интеллектуальные системы>>, pan@isa.ru
	\end{frame}
	
	\begin{frame}
		\frametitle{Динамические операторы распознавания}
		Действие динамического оператора $\hat{R}_i^j$ можно заменить последовательным действием статических операторов 
		$$
		R(\hat{x}_i^{j+1}(\tau_s), \mathcal{Z}_i^j, \bar{x}_i^j(\tau_s)), R^1(\hat{x}_i^j(\tau_s+1), \mathcal{Z}_i^j, \bar{x}_i^j(\tau_s+1)), \dots,
		$$
		$$
		R^{h_i^j-1}(\hat{x}_i^j(\tau_s+h_i^j-1), \mathcal{Z}_i^j, \bar{x}_i^j(\tau_s+h_i^j-1)),
		$$
		выдающих последовательность 
		$$
		\{\bar{x}_i^{*j}(t)|t\in|\Delta t\}=\{\bar{x}_i^{*j}(\tau_s), \bar{x}_i^{*j}(\tau_s+1), \dots, \bar{x}_i^{*j}(\tau_s+h_i^j-1)\}.
		$$
		Так как параметр $h_i^j$ фиксирован, то конечные последовательности векторов  $\omega_{i\Delta{t}}^j$ и $\gamma_{i\Delta{t}}^j$ можно считать матрицами размерности $l_i^j\times{h_i^j}$. Далее будем опускать индексы $i$ и $j$.
	\end{frame}	
\end{document}