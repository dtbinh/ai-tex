\documentclass[mathserif]{beamer}
\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{theorems}[numbered]
\usetheme{AnnArbor}
\usecolortheme{crane}


\usepackage{cmap}	% Поддержка поиска русских слов в PDF (pdflatex)
\usepackage[T2A]{fontenc}       %поддержка кириллицы
\usepackage[cp1251]{inputenc}	% Выбор языка и кодировки
\usepackage[english, russian]{babel}
\usepackage{caption}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{subfig}

\graphicspath{{../../images/}} 			% Пути к изображениям

\DeclareMathOperator*{\argmax}{arg\,max}
\algnewcommand\And{\textbf{and}}
\makeatletter
\newenvironment<>{proofs}[1][\proofname]{%
	\par
	\def\insertproofname{#1\@addpunct{.}}%
	\usebeamertemplate{proof begin}#2}
{\usebeamertemplate{proof end}}
\makeatother

\makeatletter
\newenvironment{cenumerate}{%
	\enumerate
	\setcounter{\@enumctr}{\csname saved@\@enumctr\endcsname}%
}{%
\expandafter\xdef\csname saved@\@enumctr\endcsname{\the\value{\@enumctr}}%
\endenumerate
}
\newenvironment{cenumerate*}{%
	\enumerate
}{%
\expandafter\xdef\csname saved@\@enumctr\endcsname{\the\value{\@enumctr}}%
\endenumerate
}
\makeatother

\let\Theorem\relax
\newtheorem{Theorem}{Теорема}
\newtheorem{Pred}{Утверждение}
\let\Corollary\relax
\newtheorem{Corollary}{Следствие}
\newtheorem{Def}{Определение}
\floatname{algorithm}{Алгоритм}
\algrenewcommand\algorithmicrequire{\textbf{Вход:}}
\algrenewcommand\algorithmicensure{\textbf{Выход:}}
\algrenewcommand\algorithmicreturn{\textbf{Выход:}}

\begin{document}
	
	\title[Элементы картины мира]{Исследование образной и процедурной компонент элементов картины мира субъекта деятельности}
	\author{Александр Панов}
	\institute[ИСА РАН]{ИСА РАН\\ научный руководитель д.ф.-м.н., проф. Г.\,С.~Осипов}
	\date{6 ноября 2014 г.} 
	
	\begin{frame}
		\titlepage
	\end{frame}
		
	\begin{frame}
		\frametitle{Введение}
		
		\textbf{Предмет исследования} "--- построение моделей картины мира субъекта деятельности и некоторых когнитивных функций.
		\par\bigskip
		\textbf{Целью исследования} является разработка моделей и алгоритмов формирования элементов знаковой картины мира субъекта деятельности и её функционирования.
	
	\end{frame}

	\begin{frame}
		\frametitle{Постановка задачи}
		
		Согласно современным нейрофизиологическим и психологическим данным картина мира субъекта деятельности состоит из связанных базовых элементов. Элемент картины мира является структурой, которую в различных областях знаний принято называть \textbf{знаком}. 
		\par\bigskip
		Знак имеет следующие компоненты: образ (перцепт), значение (функциональное назначение) и личностный смысл. Между этими компонентами существуют определённые связи, формирующиеся в процессе деятельности субъекта. 
		\par\bigskip
		В настоящей работе рассматриваются алгоритмы функционирования и формирования перцепта и функционального назначения, исследуется сходимость итерационного процесса связывания этих компонент и рассматриваются некоторые функции знаковой картины мира. 
	\end{frame}	
	
	\begin{frame}
		\frametitle{Знак "--- элемент картины мира}
		\begin{figure}
			\includegraphics[width=0.7\textwidth]{sign_rb}
		\end{figure}
	\end{frame}	
	
	\begin{frame}
		\frametitle{Современные представления о принципах работы коры головного мозга}
		\begin{columns}
			\begin{column}{0.2\textwidth}
				\begin{figure}
					\includegraphics[width=1.0\textwidth]{info_flow}
				\end{figure}
				\begin{figure}
					\includegraphics[width=1.0\textwidth]{multimodality}
				\end{figure}
			\end{column}
			\begin{column}{0.8\textwidth}
				Исследование перцепта опирается на работы Маунткасла, Эдейльмана и Хокинса в области нейрофизиологии и строения коры головного мозга:
				\begin{itemize}
					\item неокортекс состоит из элементарных составных элементов, которые имеют одинаковое строение на всех участках коры, объединённые латеральными связями в регионы,
					\item неокортекс хранит последовательности паттернов,
					\item неокортекс воспроизводит паттерны автоассоциативно,
					\item неокортекс предсказывает паттерны,
					\item неокортекс хранит паттерны в инвариантной иерархической форме.
				\end{itemize}
			\end{column}
		\end{columns}
	\end{frame}
	
	\begin{frame}
		\frametitle{Основные допущения и прощения}
		С целью проведения исследования модели были приняты следующие упрощения:
		\begin{itemize}
			\item дискретность во времени,
			\item простейшая строгая иерархия со связями только между ближайшими уровнями,
			\item обратная связь только по предсказанию, без моторной части,
			\item гипотеза одинаковой длительности для одной группы признаков,
			\item гипотеза <<всегда начинаем с начала>>,
			\item пороговая модель принятия решений,
			\item подавление непредвиденного сигнала.
		\end{itemize}
	\end{frame}
	
	\begin{frame}
		\frametitle{Признаки и распознающие блоки}
		Пусть заданы следующие множества:
		\begin{itemize}
			\item 
			$\{R_i^j\}$ "--- совокупность распознающих блоков,
			\item
			$\{f_k\}$ "--- совокупность допустимых признаков.
		\end{itemize}
		\par\bigskip
		Введём бинарное отношение $\dashv$, определённое на декартовом произведении $\{f_k\}{\times}\{R_i^j\}$, и будем читать $f_k{\dashv}R_i^j$ как <<признак $f_k$ распознаётся блоком $R_i^j$>>. 
		\par\bigskip	
		Множество всех распознаваемых блоком $R_i^j$ признаков будем обозначать $F_i^{*j}$, т.~е. ${\forall}f^*{\in}F_i^{*j} f^*{\dashv}R_i^j, F_i^{*j}{\subseteq}\{f_k\}$.
	\end{frame}
	
	\begin{frame}
		\frametitle{Иерархия распознающих блоков}
		\begin{figure}
			\includegraphics[width=0.5\textwidth]{rb_hierarchy}
		\end{figure}
		Рассмотрим связный ориентированный (ярусный) граф $G_R=(V,E)$:
		\begin{itemize}
			\item 
			$V$ "--- множество вершин,
			\item
			$E$ "--- множество рёбер,
			\item 
			каждая вершина $v$, принадлежащая $j$-ому ярусу графа $G_R$, связана с соответствующим распознающим блоком $R_i^j$ уровня $j$,
			\item
			каждое ребро $e=(v,u){\in}E$ обозначает иерархическую связь между соответствующим вершине $v$ дочерним блоком $R_{i_1}^{j_1 }$ и соответствующим вершине $u$ блоком"--~родителем $R_{i_2}^{j_2}$.				
		\end{itemize}
	\end{frame}
	
	\begin{frame}
		\frametitle{Входные признаки и функции распознавания}
		Определим:
		\begin{itemize}
			\item 
			для каждого распознающего блока $R_i^j$ множество $F_i^j{\subseteq}\{f_k\}$ "--- \textit{совокупность входных признаков}, в которую входят такие признаки, что для любого $f{\in}F_i^j$ существует распознающий блок $R_k^{j-1}$ уровня $j-1$, дочерний по отношению к блоку $R_i^j$, такой, что $f{\dashv}R_k^{j-1}$
			\item
			для каждого признака $f^*{\in}F_i^{*j}$ "--- \textit{функцию распознавания} $\hat{f}(x_1,\dots,x_q )=x^*$, где $x^*{\in}(0,1)$ "--- вес распознаваемого признака $f^*$, а $x_1,\dots,x_q{\in}(0,1)$ "--- вес признаков из множества входных признаков $F_i^j$,
			\item 
			множество $\hat{F}_i^j$ "--- совокупность функций распознавания для блока $R_i^j$.
		\end{itemize}
	\end{frame}
	
	\begin{frame}[t]
		\frametitle{Динамика распознающего блока}

		\vspace*{-0.5cm}
		\begin{minipage}[t]{\textwidth}
			\begin{figure}[t]
				\includegraphics[width=0.7\textwidth]{rb_cycle}
			\end{figure}
		\end{minipage}

		\begin{itemize}
			\item  $l_i^j$ "--- мощность множества измеряемых признаков $F_i^{*j}$,
			\item $q_i^j$ "--- мощность множества входных признаков $F_i^j$,
			\item $h_i^j$ "--- характерное время, за которое происходит один цикл вычисления в распознающем блоке $R_i^j$,
			\item вектор $\bar{x}_i^j(t)$ длины $l_i^j$ "--- взвешенный вектор входных признаков, 
			\item вектор $\bar{x}_i^{*j}(t)$ длины $l_i^j$ "--- взвешенный вектор распознаваемых признаков, 
			\item вектор $\hat{x}_i^j(t)$ длины $q_i^j$ "--- вектор состояние (вектор ожиданий входных признаков в следующий момент времени).
		\end{itemize}

	\end{frame}
	
	\begin{frame}
		\frametitle{Входные и выходные отображения}	
		Пусть 
		\begin{itemize}
			\item $X_i^{*j}$ "--- множество возможных мгновенных значений выходных векторов распознающего блока $R_i^j$, 
			\item $X_i^j$ "--- множество возможных мгновенных значений взвешенных векторов входных признаков, 
			\item $\hat{X}_i^j$ "--- множество всех возможных мгновенных значений векторов ожиданий или множество состояний распознающего блока $R_i^j$,
			\item $\omega_i^j:T{\to}X_i^j$ "--- входное воздействие в смысле теории динамических систем,
			\item $\gamma_i^j:T{\to}X_i^{*j}$ "--- выходная величина,
			\item $\varphi_i^j(t;\tau_s,\hat{x}_i^{j+1},\omega)=\hat{x}_i^j$ "--- функция переходов,
			\item $\eta_i^j:T{\times}\hat{X}_i^j{\to}X_i^{*j}$ "--- выходное отображение, определяющее выходные вектора $\bar{x}_i^{*j}(t)=\eta(t,\hat{x}_i^j(t))$.
		\end{itemize}
	\end{frame}	
	
	\begin{frame}
		\frametitle{Матрица предсказаний}	
		Будем считать множество моментов времени $T$ множеством целых чисел. Тогда распознающий блок $R_i^j$ будет являться \textit{динамической системой с дискретным временем}.
		\par\bigskip
		Поставим каждой функции измерения $\hat{f}_k$ из множества $\hat{F}_i^j$ в соответствие набор матриц предсказания $Z_k=\{Z_1^k,…,Z_m^k\}$ размерности $q_i^j\times h_i^j$. Тогда
		\begin{itemize}
			\item столбец $\bar{z}_u^r=(z_{u1}^k,…,z_{uq}^k)$ матрицы $Z_r^k$ "--- это вектор предсказания входных признаков из множества $F_i^j$ в момент времени $\tau_s+u$, $z_{uv}^k\in\{0,1\}$,
			\item матрица $Z_r^k$ задаёт последовательность битовых векторов, наличие бита в котором свидетельствует о присутствии измеряемого функцией $\hat{f}_k$ признака,
			\item $\mathcal{Z}_i^j$ "--- множество всех матриц предсказания распознающего блока $R_i^j$.
		\end{itemize}
	\end{frame}	
	
	\begin{frame}
		\frametitle{Алгоритм $\mathfrak A_{th}$ работы вычислительного блока}
		
		Разработан пороговый алгоритм $\mathfrak A_{th}(c_1,c_2)$ вычисления функции переходов $\varphi_i^j$ и выходного отображения $\eta_i^j$ по начальному моменту времени $\tau_s$, управляющему воздействию $\hat x_i^{j+1}(\tau_s)$ и входному воздействию $\omega_i^j$. 
		
		\par\bigskip
		На основании данного алгоритма далее будут построены 4 типа операторов распознавания, сформулированы задачи классификации по Ю.\,И.~Журавлёву и доказаны теоремы корректности линейных замыканий множеств этих операторов.
	\end{frame}

	\begin{frame}
		\frametitle{Статический оператор распознавания}
		Зафиксируем момент времени $t$, равный началу некоторого $s$-го вычислительного цикла $\tau_s$. 
		\par\bigskip
		В этом случае, распознающий блок $R_i^j$ можно рассматривать как статический оператор распознавания $R_i^j(\hat{x}_i^{j+1},\mathcal{Z}_i^j,\bar{x}_i^j)=\bar{x}_i^{*j}$.
	\end{frame}
		
	\begin{frame}
		\frametitle{Задача классификации}
		Пусть
		\begin{itemize}
			\item $\{Q\}$ "--- совокупность задач классификации,
			\item $\{\mathcal{A}\}$ "--- множество алгоритмов, переводящих пары $(\hat{x},\bar{x})$ в вектора $\bar{\beta}$, составленные из элементов $0,1,\Delta:\mathcal{A}(\hat{x},\bar{x})=\bar{\beta}$. Если $\beta_i\in\{0,1\}$, то $\beta_i$ "--- значение величины $\alpha_i$, вычисленное алгоритмом $\mathcal{A}$. Если $\beta_i=\Delta$, то алгоритм $\mathcal{A}$ не вычислил значение $\alpha_i$.
		\end{itemize}
		\par\bigskip
		\begin{columns}
			\begin{column}{0.75\textwidth}
				Задача $Q(\hat{x},\bar{x},\alpha_1,\dots,\alpha_l)\in\{Q\}$ состоит в построении алгоритма, вычисляющего по поступившему вектору ожиданий $\hat{x}$ и входному вектору $\bar{x}$ значения $\alpha_1,\dots,\alpha_l\in\{0,1\}$ присутствия признаков $f_1^*,…,f_l^*$. Другими словами, искомый алгоритм $\mathcal{A}^*$ переводит набор $(\hat{x},\bar{x})$ в вектор $\bar{\alpha}=(\alpha_1,\dots,\alpha_l)$, который будем называть информационным вектором входного вектора $\bar{x}$.
			\end{column}
			\begin{column}{0.25\textwidth}
				\begin{figure}[t]
					\includegraphics[width=1.0\linewidth,page=1]{rb_correct}
				\end{figure}
			\end{column}	
		\end{columns}
	\end{frame}
	
	\begin{frame}
		\frametitle{Свойство корректности алгоритма}
		\begin{Def}
			Алгоритм $\mathcal{A}$ называется корректным для задачи $Q$, если выполнено равенство
			$$
			\mathcal{A}(\hat{x},\bar{x})=\bar{\alpha}.
			$$
			Алгоритм $\mathcal{A}$, не являющийся корректным для $Q$, называется некорректным.
		\end{Def}
		\par\bigskip		
		Далее будем считать, что множество $\{\mathcal{A}\}$ является совокупностью, вообще говоря, некорректных алгоритмов.
		\par\bigskip
		Отличие от известной постановки: используются вектора, а не матрицы при формулировке соответствующих определений и утверждений.
	\end{frame}
	
	\begin{frame}
		\frametitle{Разложение алгоритма классификации}
		\begin{Pred}[аналог теоремы 1, Журавлёв]\label{st:decompositon}
			Каждый алгоритм $\mathcal{A}\in\{\mathcal{A}\}$ представим как последовательность выполнения алгоритмов $R$ и $C$, где $R(\hat{x},\bar{x})=\bar{x}^*$, $\bar{x}^*$ "--- вектор действительных чисел, $C(\bar{x}^*)=\bar{\beta}$, $\beta_i\in\{0,1,\Delta\}$.
		\end{Pred}
		\par\bigskip
		\begin{itemize}
			\item $R$ "--- оператор распознавания,
			\item $C$ "--- решающее правило.
		\end{itemize}
	\end{frame}
	
	\begin{frame}
		\frametitle{Решающее правило и операции над алгоритмами}
		\begin{Def}
			Решающее правило $C^*$ называется корректным на множестве входных векторов $X$, если для всякого вектора $\bar{x}$ из $X$ существует хотя бы один числовой вектор $\bar{x}^*$ такой, что $C^*(\bar{x}^*)=\bar{\alpha}$, где $\bar{\alpha}$ "--- информационный вектор входного вектора $\bar{x}$.
		\end{Def}
		В множестве операторов $\{R\}$ введём операции умножения на скаляр, сложения и умножения. Пусть $r'$ "--- скаляр, $R',R''\in\{R\}$. Определим операторы $r'{\cdot}R'$, $R'+R''$ и $R{\cdot}R''$ следующим образом:
		\begin{equation}
			\label{eq:oper_scalar}
			r'{\cdot}R'=(r'{\cdot}{x_1^*}',\dots,r'{\cdot}{x_l^*}'),
		\end{equation}
		\begin{equation}
			\label{eq:oper_sum}
			R'+R''=({x_1^*}'+{x_1^*}'',\dots,{x_1^*}'+{x_l^*}''),
		\end{equation}
		\begin{equation}
			\label{eq:oper_mult}
			R'{\cdot}R''=({x_1^*}'{\cdot}{x_1^*}'',\dots,{x_1^*}'{\cdot}{x_l^*}'').
		\end{equation}
	\end{frame}
	
	\begin{frame}
		\frametitle{Замыкание множества алгоритмов}
		\begin{Pred}
			Замыкание $L\{R\}$ множества $\{R\}$ относительно операций \eqref{eq:oper_scalar} и \eqref{eq:oper_sum} является векторным пространством.
		\end{Pred}
		\begin{Pred}
			Замыкание $\mathfrak{U}\{R\}$ множества $\{R\}$ относительно операций \eqref{eq:oper_scalar}, \eqref{eq:oper_sum} и \eqref{eq:oper_mult} является ассоциативной линейной алгеброй с коммутативным умножением.
		\end{Pred}
		\begin{Def}
			Множества $L\{A\}$ и $\mathfrak{U}\{A\}$ алгоритмов $\mathcal{A}=R{\cdot}C^*$ соответственно таких, что $R{\in}L\{R\}$ и $R\in\mathfrak{U}\{R\}$, соответственно называются линейными и алгебраическими замыканиями множества $\{\mathcal{A}\}$.
		\end{Def}
	\end{frame}
	
	\begin{frame}
		\frametitle{Свойство полноты задачи}
		Зафиксируем пару $(\hat{x},\bar{x})$ управляющего вектора и входного вектора. Будем рассматривать задачи $Q(\hat{x},\bar{x})$, обладающие следующим свойством относительно множества операторов распознавания $\mathcal{R}$.
		
		\begin{Def}
			Если множество векторов $\{R(\hat{x},\bar{x})\}$, где $R$ пробегает некоторое множество операторов распознавания $\mathcal{R}$, содержит базис в пространстве числовых векторов длины $l$, то задача $Q(\hat{x},\bar{x},\bar{\alpha})$ называется полной относительно $\mathcal{R}$.
		\end{Def}
	\end{frame}
	
	\begin{frame}
		\frametitle{Связь свойств полноты и корректности}
		\begin{Pred}[аналог теоремы 2, Журавлёв]\label{st:correctness}
			Если множество задач $\{Q\}$ состоит лишь из задач, полных относительно $\mathfrak{R}$, то линейное замыкание $L\{R{\cdot}C^*\}$ ($C^*$ "--- произвольное фиксированное корректное решающее правило, $R$ пробегает множество $\mathcal{R}$) является корректным относительно $\{Q\}$.
		\end{Pred}
	\end{frame}
	
	\begin{frame}
		\frametitle{Основная теорема корректности в статическом случае}
		Будем рассматривать только такие задачи $Q(\hat{x},\bar{x},\bar{\alpha})$, для которых удовлетворяется следующее условие: ${\exists}k$ такое, что $x_k$ является $k$-ым элементом вектора $\bar{x}$ и $x_k>1/2$. 
		\par\bigskip
		\begin{Theorem}[А.\,И.~Панов]
			\label{th:correctness}
			Линейное замыкание $L\{\mathcal{A}\}$ семейства алгоритмов $\{\mathcal{A}\}=\{R{\cdot}C^*\}$ с произвольным корректным решающим правилом $C^*$ и операторами распознавания $R$, определёнными алгоритмом $\mathfrak{A}_{th}$, является корректным на $\{Q\}$.
		\end{Theorem}
	\end{frame}
	
	\begin{frame}
		\frametitle{Операторы распознавания $R^t$}
		Фиксация момента времени не в начале вычислительного цикла, а на любом другом значении $\tau_s<t<\tau_s+h_i^j$, приводит к операторам вида $R_i^j(\hat{x}_i^j(t), \mathcal{Z}_i^j, \bar{x}_i^j(t))$, который кратко будем записывать $R^t$. 
		\par\bigskip
		\begin{columns}
			\begin{column}{0.7\textwidth}		
				Для этих операторов постановка задачи распознавания выглядит таким же образом как и для операторов $R$, формулировки определений полноты и корректности идентичны. Теорема о корректности линейного замыкания $L\{R^t\cdot{C^*}\}$ доказывается аналогично.
			\end{column}
			\begin{column}{0.3\textwidth}
				\begin{figure}[t]
					\includegraphics[width=1.0\linewidth,page=2]{rb_correct}
				\end{figure}
			\end{column}			
		\end{columns}
	\end{frame}
	
	\begin{frame}
		\frametitle{Динамические операторы распознавания}
		Будем фиксировать не конкретный момент времени $t$, а промежуток времени ${\Delta}t=[\tau_s,\tau_s+h_i^j)$. 
		\par\bigskip
		\begin{columns}
			\begin{column}{0.7\textwidth}
				В этом случае распознающий блок $R_i^j$ можно рассматривать как \textit{динамический оператор распознавания} $\hat{R}_i^j(\hat{x}_i^{j+1}(\tau_s), \mathcal{Z}_i^j, \omega_{i\Delta{t}}^j)=\gamma_{i\Delta{t}}^j$
				\begin{itemize}
					\item принимающий  функцию входного воздействия $\omega_i^j$, ограниченную на промежутке времени ${\Delta}t$ и 
					\item выдающий функцию выходной величины $\gamma_i^j$ на том же временном промежутке. 
				\end{itemize}
			\end{column}
			\begin{column}{0.3\textwidth}
				\begin{figure}[t]
					\includegraphics[width=1.0\linewidth,page=3]{rb_correct}
				\end{figure}
			\end{column}
		\end{columns}
	\end{frame}
	
	\begin{frame}
		\frametitle{Динамические операторы распознавания}
		Действие динамического оператора $\hat{R}_i^j$ можно заменить последовательным действием статических операторов 
		$$
		R(\hat{x}_i^{j+1}(\tau_s), \mathcal{Z}_i^j, \bar{x}_i^j(\tau_s)), R^1(\hat{x}_i^j(\tau_s+1), \mathcal{Z}_i^j, \bar{x}_i^j(\tau_s+1)), \dots,
		$$
		$$
		R^{h_i^j-1}(\hat{x}_i^j(\tau_s+h_i^j-1), \mathcal{Z}_i^j, \bar{x}_i^j(\tau_s+h_i^j-1)),
		$$
		в результате выдающих последовательность 
		$$
		\{\bar{x}_i^{*j}(t)\}=\{\bar{x}_i^{*j}(\tau_s), \bar{x}_i^{*j}(\tau_s+1), \dots, \bar{x}_i^{*j}(\tau_s+h_i^j-1)\}.
		$$
		Так как параметр $h_i^j$ фиксирован, то конечные последовательности векторов  $\omega_{i\Delta{t}}^j$ и $\gamma_{i\Delta{t}}^j$ можно считать матрицами размерности $l_i^j\times{h_i^j}$. Далее будем опускать индексы $i$ и $j$.
	\end{frame}
	
	\begin{frame}
		\frametitle{Задача классификацииу}
		Задача $\hat{Q}(\hat{x}, \omega_{{\Delta}t}, \bar{\alpha})$ состоит в построении алгоритма $\hat{\mathcal{A}}$, вычисляющего по поступившему начальному (управляющему) вектору ожиданий $\hat{x}$ и матрице входных воздействий $\omega_{{\Delta}t}$  последовательность векторов $\beta_{\Delta{t}}$, монотонно сходящуюся к информационному вектору $\bar{\alpha}$. 
		\par\bigskip
		Искомый оператор распознавания $\hat{R}$ должен выдавать весовую матрицу измеряемых признаков $\gamma_{\Delta{t}}$, столбцы которой должны сходиться (с учётом корректного решающего правила) к информационному вектору: $\lim_{t\to\tau_s+h}\bar{x}^*(t)=\bar{\alpha}$. 
	\end{frame}
	
	\begin{frame}
		\frametitle{Свойство корректность алгоритма}
		\begin{Def}
			Алгоритм $\hat{\mathcal{A}}(\hat{x},\bar{x})=\beta_{\Delta{t}}=(\bar{\beta}_1,\dots,\bar{\beta}_h)$ называется корректным для задачи $\hat{Q}$, если выполнено условие
			$$
			\|\bar{\beta}_1-\bar{\alpha}\|\geqslant\|\bar{\beta}_2-\bar{\alpha}\|\geqslant\dots\geqslant\|\bar{\beta}_h-\bar{\alpha}\|,
			$$
			причём $\|\bar{\beta}_h-\bar{\alpha}\|=0$. $\|\bar{\beta}_i-\bar{\alpha}\|=\sum_j{(\beta_{ij}-\alpha_j)}$, где $\beta_{ij}-\alpha_j=0$, если $\beta_{ij}=\alpha_j$, $\beta_{ij}-\alpha_j=\frac{1}{2}$, если $\beta_{ij}=\Delta$, и $\beta_{ij}-\alpha_j=0$ иначе. Алгоритм $\hat{\mathcal{A}}$, не являющийся корректным для $\hat{Q}$, называется некорректным.
		\end{Def}
	\end{frame}
	
	\begin{frame}
		\frametitle{Разложимость алгоритма}
		\begin{Pred}\label{st:decompositon_dyn}
			Каждый алгоритм $\hat{\mathcal{A}}\in\{\hat{\mathcal{A}}\}$ представим как последовательность выполнения алгоритмов $\hat{R}$ и $\hat{C}$, где $\hat{R}(\hat{x}, \mathcal{Z}, \omega_{\Delta{t}})=\gamma_{\Delta{t}}$, $\gamma_{\Delta{t}}$ "--- матрица действительных чисел, $\hat{C}(\gamma_{\Delta{t}})=\beta_{\Delta{t}}$, $\beta_{\Delta{t}}$ "--- матрица значений $\beta_{ij}\in\{0,1,\Delta\}$.
		\end{Pred}
	\end{frame}
	
	\begin{frame}
		\frametitle{Корректное решающее правило}
		Корректное решающее правило $\hat{C}^*$ для матрицы $\gamma_{\Delta{t}}$ определяется через набор корректных правил для векторов $(C_1^*, \dots, C_h^*)$ таких, что 
		$$
		\|C_1^*(\bar{x}^*(\tau_s))-\bar{\alpha}\|\geqslant\|C_2^*(\bar{x}^*(\tau_s+1))-\bar{\alpha}\|\geqslant\dots\geqslant
		$$
		$$
		\geqslant\|C_h^*(\bar{x}^*(\tau_s+h-1))-\bar{\alpha}\|,
		$$ 
		причём последняя норма равна нулю. В простейшем случае $\forall{i}$ $C_i^*(\bar{x}^*(\tau_s+i))=\bar{\alpha}$. 
		\par\bigskip
		Аналогично статическому случаю вводятся определения линейного $L\{\hat{R}\}$ и алгебраического $\mathfrak{U}\{\hat{R}\}$ замыкания над множеством $\{\hat{R}\}$. 
	\end{frame}
	
	\begin{frame}
		\frametitle{Основная теорема корректности в динамическом случае}
		Зафиксируем начальный вектора ожиданий $\hat{x}$ и последовательность входных векторов $\omega_{\Delta{t}}$. 
		\par\bigskip
		Если, как и в статическом случае, будем рассматривать только такие задачи $\hat{Q}(\hat{x},\omega_{\Delta{t}},\bar{\alpha})$, для которых в матрице $\omega_{\Delta{t}}$ в каждом столбце с номером $s$ ${\exists}k$ такое, что $x_{sk}$ является $k$-ым элементом вектора $\bar{x}(\tau_s+s)$ и $x_{sk}>1/2$, то можно сформулировать следующую теорему.
		
		\begin{Theorem}[А.\,И.~Панов]\label{th:dyn_correct}
			Линейное замыкание $L\{\hat{\mathcal{A}}\}$ семейства алгоритмов $\{\hat{\mathcal{A}}\}=\{\hat{R}{\cdot}\hat{C}^*\}$ с произвольным корректным решающим правилом $\hat{C}^*$ и операторами распознавания $\hat{R}$, определёнными алгоритмом $\mathfrak{A}_{th}$, является корректным на $\{\hat{Q}\}$.
		\end{Theorem}
	\end{frame}
	
	\begin{frame}
		\frametitle{Иерархический оператор распознавания}
		\begin{columns}
			\begin{column}{0.7\textwidth}
				Для обоснования корректности иерархии операторов динамического распознавания, рассмотрим пример из двухуровневой иерархии, на каждом уровне которой находится по~одному оператору: статический $R_{i_1}^{j+1}(\hat x _{i_1}^{j+2},\bar x_{i_1}^{j+1}(\tau_s),\bar\alpha_{i_1}^{j+1})$ на верхнем уровне и динамический $\hat R_{i_2}^j(\hat x _{i_2}^{j+1},\omega_{i_2\Delta t}^j,\bar\alpha_{i_2}^j)$ "--- на нижнем.
			\end{column}
			\begin{column}{0.3\textwidth}
				\begin{figure}[t]
					\includegraphics[width=1.0\linewidth,page=4]{rb_correct}
				\end{figure}
			\end{column}
		\end{columns}
		
		\par\bigskip
		Данную иерархию можно рассматривать как иерархический оператор распознавания $\hat R_{e,j}^2(\hat x_{i_1}^{j+1}(\tau_s),\mathcal Z_{i_1}^{j+1},\mathcal Z_{i_2}^j,\omega_{i_2\Delta t}^j)=\bar x_{i_1}^{*j+1}$, принимающий функцию входного воздействия $\omega_{i_2\Delta t}^j$ нижнего уровня, ограниченную на промежутке времени $\Delta t$, и выдающий взвешенный вектор распознаваемых признаков $\bar x_{i_1}^{*j+1}$.
	\end{frame}	
	
	\begin{frame}
		\frametitle{Задача классификации}
		Задача $\hat Q_{e,j}^2(\hat x_{i_1}^{j+2},\omega_{i_2\Delta t}^j,\bar\alpha_{i_1}^{j+1})$ состоит в построении алгоритма $\hat{\mathcal A_e}$, вычисляющего по поступившему начальному вектору ожиданий $\hat x_{i_1}^{j+2}$ и матрице входных воздействий $\omega_{i_2\Delta t}^j$ значения информационного вектора $\bar\alpha_{i_1}^{j+1}$.
	\end{frame}	
	
	\begin{frame}
		\frametitle{Основная теорема корректности в иерархическом случае}
		Зафиксируем начальный вектор ожиданий $\hat x_{i_1}^{j+2}$ и последовательность входных векторов $\omega_{i_2\Delta{t}}^j$. 
		\par\bigskip
		Если мы будем рассматривать только такие задачи $\hat Q_{e,j}^2(\hat x_{i_1}^{j+2},\omega_{i_2\Delta{t}}^j,\bar\alpha_{i_1}^{j+1})$, для которых в матрице $\omega_{i_2\Delta{t}}^j$ в каждом столбце с номером $s$ ${\exists}k$ такое, что $x_{sk}$ является $k$-ым элементом вектора $\bar x_{i_2}^j(\tau_s+s)$ и $x_{sk}>1/2$, то можно сформулировать следующую теорему.
		
		\begin{Theorem}[А.\,И.~Панов]\label{th:hier_correct}
			Линейное замыкание $L\{\hat{\mathcal A_e}\}$ семейства алгоритмов $\{\hat{\mathcal A}_e\}=\{\hat R_{e,j}^2\cdot\hat C_e^*\}$ с произвольным корректным решающим правилом $\hat C_e^*$ и операторами распознавания $\hat R_{e,j}^2$, определёнными алгоритмом $\mathfrak A_{th}$, является корректным на~множестве задач $\{\hat Q_{e,j}^2\}$.
		\end{Theorem}
	\end{frame}
	
	\begin{frame}[t]
		\frametitle{Схема алгоритма формирования знака}
		\begin{cenumerate*}
			\item Формирование перцепта.
			\item Порождение на основе прошлого опыта или на основе прецедентов "--- множества пар вида ``перцепт "--- функциональное значение'' "--- функционального значения объекта.
			\item Получение субъектом из культурной среды, аккумулированной в системе естественного языка, пары ``имя знака "--- значение'' и оценка специальным механизмом степени близости функционального значения, построенного на стадии 1 к значению, полученному из культурной среды; в случае недостаточной близости "--- переход к п. 1 и продолжение формирования перцепта.
			\item Связывание имени из пары ``имя знака "--- значение'' с перцептом, построенным после завершения выполнения п. 1–3; с этого момента перцепт превращается в образ.
		\end{cenumerate*}
	\end{frame}
	
	\begin{frame}[t]
		\frametitle{Схема алгоритма формирования знака}
		\begin{cenumerate}
			\item Формирование личностных смыслов знака на основе прецедентов действий с предметом.
			\item Связывание имени из пары ``имя знака "--- значение'' со сформированным личностным смыслом. С этого момента функциональное значение превращается в значение, а биологический смысл "--- в личностный смысл.
			\item Продолжение отображения ``биологический смысл "--- перцепт'' включением в область определения отображения личностного смысла, полученного в предыдущем пункте, а в область значений "--- образа из п. 4.
		\end{cenumerate}
	\end{frame}	
	
	\begin{frame}
		\frametitle{Отношения измеримости}
		Введём семейство бинарных отношений $\{\sqsubset,\sqsubset^1,\sqsubset^2,\dots\}$, определённых на декартовом произведении $\{f_k\}\times \{f_k\}$. 
		\par\bigskip
		``Признак $f_1$ является составляющим признака $f_2$'' или ``признак $f_2$ измеряется по признаку $f_1$'', $(f_1,f_2 )\in\sqsubset$ или $f_1\sqsubset f_2$, в том случае, если $f_1\dashv R_1^j, f_2\dashv R_2^{j+1}$, $R_2^{j+1}$ "--- родительский блок по отношению к $R_1^j$ и в множестве матриц предсказания $\mathcal Z_2$ признака $f_2$ существует как минимум одна матрица $Z_r^2$, содержащая некоторый столбец $\bar z_u^r$ с элементом $z_{uv}^r\not=0$, где $v$ "--- индекс признака $f_1$ во входном векторе вероятностей для распознающего блока $R_2^{j+1}$.
	\end{frame}
	
	\begin{frame}
		\frametitle{Отношения измеримости}		
		Пара признаков $(f_1,f_2)\in\sqsubset^t$ или $f_1\sqsubset^t f_2$, где $t\in\{1,2,\dots\}$, в том случае, если $f_1\dashv R_1^j, f_2\dashv R_2^{j+1}$, $R_2^{j+1}$ "--- родительский блок по отношению к $R_1^j$ и в множестве матриц предсказания $\mathcal Z_2$ признака $f_2$ существует как минимум одна матрица $Z_r^2$, содержащая $t$–ый столбец $\bar z_t^r$ с элементом $z_{tv}^r\not=0$, где $v$ "--- индекс признака $f_1$ во входном векторе вероятностей для распознающего блока $R_2^{j+1}$.
		\par\bigskip
		Каждый элемент векторов-столбцов соотносится с признаком из входного множества признаков распознающего блока, что означает задание типа для каждого элемента вектора-столбца. Будем обозначать тип $k$-го элемента вектора-столбца распознающего блока $R_i^j$ как $f_i^j(k)\in F_i^j$, $k\in(1,q_i^j)$. 
	\end{frame}
	
	\begin{frame}
		\frametitle{Признаки ``условие'' и ``эффект''}
		Для описания действий будем использовать правила, которые в искусственном интеллекте представляются собой множества условий и эффектов. Введём два выделенных из множества $\{f_k\}$ признака: $f_c$ "--- ``условие'' и $f_e$ "--- ``эффект'', измеряемые распознающим блоком $R_0^1$.
		\begin{Def}
			Те признаки, которые измеряются распознающими блоками, выступающими родительскими по отношению к блоку $R_0^1$, будем называть процедурными признаками, остальные "--- объектными признаками.
		\end{Def}
		Для любого процедурного признака выполняются следующие естественные условия:
		\begin{itemize}
			\item условие всегда предшествует эффекту,
			\item условие всегда влечёт за собой эффект и
			\item все условия всегда отделены от своих эффектов.
		\end{itemize}
	\end{frame}
	
	\begin{frame}
		\frametitle{Столбцы условий и эффектов}
		\begin{Def}
			Те столбцы матрицы предсказания $Z$, в которых соответствующий признаку $f_e$ элемент вектора не нулевой, будем называть столбцами эффектов, а те столбцы матрицы предсказания $Z$, в которых не равен нулю элемент вектора, соответствующий признаку $f_c$ -- столбцами условий. 
		\end{Def}
		\par\bigskip
		Пополним семейство отношений $\{\sqsubset,\sqsubset^1,\sqsubset^2,\dots\}$ двумя отношениями: $\sqsubset^c$ и $\sqsubset^e$, принадлежность к которым пары признаков $(f_1,f_2)$ свидетельствует о том, что признак $f_1$ присутствует соответственно в столбце условий и эффектов как минимум в одной матрице предсказания процедурного признака $f_2$.
	\end{frame}
	
	\begin{frame}
		\frametitle{Перцепт}
		\begin{Def}
			Если $f_1$ "--- признак, то подмножество $\tilde p(f_1)$ множества $\{f_k\}$ таких признаков, что $\forall f_i\in\tilde p(f_1) f_i\sqsubset f_1$, будем называть перцептом признака $f_1$.
		\end{Def}
		
		На множестве всех перцептов $\tilde P$ введём метрику $\rho_p(\tilde p(f_1),\tilde p(f_2))$, вычисляемую по следующему правилу:
		\begin{itemize}
			\item если $f_1$ и $f_2$ измеряются разными распознающими блоками, т.е. $f_1\dashv R_1^j, f_2\dashv R_2^i$, то $\rho_p(\tilde p(f_1),\tilde p(f_2))=\infty$,
			\item если $f_1$ и $f_2$ измеряются одним и тем же распознающим блоком $R_1^j$ со множеством входных признаков $F_1^j$ мощности $q$ и характерным временем $h$, то
			\begin{equation}
			\rho_p(\tilde p(f_1),\tilde p(f_2))=\min\limits_{\substack{Z_r^1\in Z_1\\Z_s^2\in Z_2}}\frac{1}{q\cdot h}\sum\limits_{u=1}^h\|\bar z_u^r-\bar z_u^s\|.
			\end{equation} 
		\end{itemize}
		
	\end{frame}
	
	\begin{frame}
		\frametitle{Функциональное значение}
		\begin{Def}
			Если $f_1$ "--- признак, $f_2$ "--- процедурный признак, $f_1\sqsubset^c f_2$, то будем называть $f_2$ функциональным значением признака $f_1$. Множество всех функциональных значений признака $f_1$ будем обозначать $\tilde m(f_1)$.
		\end{Def}
		
		На множестве всех функциональных значений $\tilde M$ введём метрику $\rho_m(\tilde m(f_1),\tilde m(f_2))$ следующим образом:
		\begin{equation}
		\rho_m(\tilde m_1(f_1),\tilde m_2(f_2 ))=\min\limits_{\substack{f_i\in\tilde m(f_1 )\\f_j\in\tilde m(f_2 )}}\rho_p(\tilde p(f_i ),\tilde p(f_j )).
		\end{equation}
	\end{frame}
	
	\begin{frame}
		\frametitle{Матрица предсказаний процедурного признака}
		Матрицу предсказания $Z_r^p$ процедурного признака $f_p$ всегда можно представить в следующем виде:
		$$
		Z_r^p=(\bar z_1^{r,c},\dots,\bar z_{j_1}^{r,c},\bar z_{j_{1+1}}^{r,e},\dots,\bar z_{i_1}^{r,e},\dots,\dots,
		$$
		$$
		\bar z_{i_{k-1}+1}^{r,c},\dots,\bar z_{j_k}^{r,c},\bar z_{j_k+1}^{r,e},\dots,\bar z_{i_k}^{r,e}),
		$$
		где $\bar z_j^{r,c}$ "--- столбцы причин, $\bar z_i^{r,e}$ "--- столбцы следствий. 
		\par\bigskip
		Величину $k$ будем называть актностью процедурного признака. В дальнейшем будем рассматривать простые матрицы предсказаний $k$-актного процедурного признака:
		$$
		Z_r^p=(\bar z_1^{r,c},\bar z_2^{r,e},\dots,\dots,\bar z_{2\cdot k-1}^{r,c},\bar z_{2\cdot k}^{r,e}).
		$$
		\par\bigskip
		Краткая форма $k$-актного процедурного признака $f_p$ имеет матрицу предсказания, в которой оставлены только первый столбец условий и последний столбец эффектов.
	\end{frame}
	
	\begin{frame}
		\frametitle{Процедурный признак как правило}
		Любой одноактный процедурный признак $f_p$, измеряемый распознающим блоком $R_i^j$, можно представить в виде правила $r_p=(F_C(f_p),F_A(f_p),F_D(f_p))$, в котором:
		\begin{itemize}
			\item $F_C (f_p )\subseteq F_i^j$ "--- множество признаков "--- условий правила: $\forall f\in F_C(f_p)$ $f\sqsubset^c f_p$;
			\item $F_A(f_p)\subseteq F_i^j$ "--- множество добавляемых правилом признаков: $\forall f\in F_A(f_p)$ $f\sqsubset^e f_p,f\notin F_C$;
			\item $F_D(f_p)\subseteq F_i^j$ "--- множество удаляемых правилом признаков: $\forall f\in F_D(f_p)$ $f\notin F_A,f\in F_C$.
		\end{itemize}
	\end{frame}
	
	\begin{frame}
		\frametitle{Свойство выполнимости}
		\begin{Def}
			Процедурный признак $f_p^1$ c матрицей предсказания $Z=(\bar z_1^c,\bar z_2^e)$ выполняется на векторе $z$ длины $q$, если $z\cdot \bar z_1^c=\bar z_1^c$.
		\end{Def}
		Будем говорить, что процедурный признак $f_p^1$ выполним в условиях процедурного признака $f_p^2$, если 
		\begin{itemize}
			\item оба признака измеряются одним и тем же распознающим блоком $R_i^j$ и признак  $f_p^1$ выполняется на столбце условий матрицы предсказания признака $f_p^2$,
			\item $f_p^1\dashv R_1^{j_1}, f_p^2\dashv R_2^{j_2}$, множества $F_C(f_p^1 )$ и $F_C(f_p^2)$ состоят из одних и тех же признаков, образуемый вектор $\tilde z$ (той же мощности, что и множество $F_1^{j_1}$) элементы которого, соответствующие признакам из $F_C(f_p^2)$ принимаются равными $1$,  остальные "--- $0$, и признак $f_p^1$ выполним на векторе $\tilde z$. 
		\end{itemize}
	\end{frame}
	
	\begin{frame}
		\frametitle{Свойство конфликтности}
		\begin{Def}
			Будем говорить, что два процедурных признака $f_p^1$ и $f_p^2$ конфликтуют, если выполнено как минимум одно из следующих условий:
			\begin{itemize}
				\item $F_D(f_p^1)\cap F_A(f_p^2)\not=\varnothing$,
				\item $F_D(f_p^2)\cap F_A(f_p^1)\not=\varnothing$,
				\item $F_D(f_p^1)\cap F_C(f_p^2)\not=\varnothing$,
				\item $F_D(f_p^2)\cap F_C(f_p^1)\not=\varnothing$.
			\end{itemize}
		\end{Def}
	\end{frame}
	
	\begin{frame}
		\frametitle{Операции приведения признаков}
		\begin{Def}
			Операцией сохраняющего приведения вектор-столбца $\bar z_1$ к множеству входных признаков $F_{i_2}^{j_2}$ будем называть такой вектор $\bar z_3$ длины $q_{i_2}^{j_2}$, элемент которого $z_{3k}=1$, если $f_{i_1}^{j_1}(k)=f_{i_2}^{j_2}(k)$ и $z_{1k}=1$, иначе $z_{3k}=0$, и обозначать $(\bar z_1\rightarrow F_{i_2}^{j_2})=\bar z_3$.
		\end{Def}
		
		\begin{Def}
			Операцией сужающего приведения вектор-столбца $\bar z_1$ к некоторому столбцу $\bar z_2$ распознающего блока $R_{i_2}^{j_2}$ будем называть такой вектор $\bar z_3$ длины $q_{i_2}^{j_2}$, элемент которого $z_{3k}=1$, если $f_{i_1}^{j_1}(k)=f_{i_2}^{j_2}(k)$, $z_{2k}=1$ и $z_{1k}=1$, иначе $z_{3k}=0$, и обозначать $(\bar z_1\Rightarrow \bar z_2)=\bar z_3$.
		\end{Def}
	\end{frame}
	
	\begin{frame}
		\frametitle{Опыт наблюдения}
		У субъекта имеется опыт наблюдения, который выражается в виде отношения $\Psi_p^m$: $\tilde p\Psi_p^m \tilde m$, или $\Psi_p^m(\tilde p)=\tilde m$, в том случае, если $\tilde p\in\tilde P$ является перцептом некоторого признака $f$, а $\tilde m\in\tilde M$ -- функциональным значением того же признака $f$.
		\par\bigskip
		Разработан итерационный алгоритм $\mathfrak A_{pm}$ доопределения функции $\Psi_p^m$, который обеспечивает построение такого перцепта из множества признаков $\hat F$, при котором формируемое функциональное значение сходится к значению $\tilde m=\{f_p\}$, полученному из внешней среды.
	\end{frame}
	
	\begin{frame}[t]
		\frametitle{Алгоритм $\mathfrak{A}_{pm}$ доопределения функции $\Psi_p^m$}
		\only<1>{
			\begin{algorithm}[H]
				\caption*{Алгоритм $\mathfrak{A}_{pm}$ (часть I)}
				\begin{algorithmic}[1]
					\Require $\tilde m=\{f_p\}, \Psi_p^m, \hat F\subseteq \{f_k\}$;
					\algstore*{store1}
				\end{algorithmic}
			\end{algorithm}
		}
		\only<2>{
			\begin{algorithm}[H]
				\caption*{Алгоритм $\mathfrak{A}_{pm}$ (часть I)}
				\begin{algorithmic}[1]
					\Require $\tilde m=\{f_p\}, \Psi_p^m, \hat F\subseteq \{f_k\}$;
					\State $\tilde p^{*(0)} := \varnothing$;
					\State $Z^{*(0)} := \varnothing$;
					\State $t := 0$;
					\algstore*{store2}				
				\end{algorithmic}
			\end{algorithm}
		}
		\only<3>{
			\begin{algorithm}[H]
				\caption*{Алгоритм $\mathfrak{A}_{pm}$ (часть I)}
				\begin{algorithmic}[1]
					\Require $\tilde m=\{f_p\}, \Psi_p^m, \hat F\subseteq \{f_k\}$;
					\State $\tilde p^{*(0)} := \varnothing$;
					\State $Z^{*(0)} := \varnothing$;
					\State $t := 0$;
					\ForAll{$f^{(t)}\in \hat F$}
					\algstore*{store3}				
				\end{algorithmic}
			\end{algorithm}
		}
		\only<4>{
			\begin{algorithm}[H]
				\caption*{Алгоритм $\mathfrak{A}_{pm}$ (часть I)}
				\begin{algorithmic}[1]
					\Require $\tilde m=\{f_p\}, \Psi_p^m, \hat F\subseteq \{f_k\}$;
					\State $\tilde p^{*(0)} := \varnothing$;
					\State $Z^{*(0)} := \varnothing$;
					\State $t := 0$;
					\ForAll{$f^{(t)}\in \hat F$}
					\If{$\exists \tilde m^{(t)}\in \tilde M$ такое, что $\tilde p(f^{(t)}),\tilde m^{(t)})\in\Psi_p^m$ \textbf{and}
						\\\hspace{0.5cm}$\tilde m^{(t)}$ выполним в условиях признака $f_p$ \textbf{and}
						\\\hspace{0.5cm}$\nexists f: f\in\tilde p^{*(t)},(\tilde p(f),\tilde m(f))\in\Psi_p^m, \tilde m$ конфликтует с $\tilde m^{(t)}$
					}
					\algstore*{store4}				
				\end{algorithmic}
			\end{algorithm}
		}
		\only<5>{
			\begin{algorithm}[H]
				\caption*{Алгоритм $\mathfrak{A}_{pm}$ (часть I)}
				\begin{algorithmic}[1]
					\Require $\tilde m=\{f_p\}, \Psi_p^m, \hat F\subseteq \{f_k\}$;
					\State $\tilde p^{*(0)} := \varnothing$;
					\State $Z^{*(0)} := \varnothing$;
					\State $t := 0$;
					\ForAll{$f^{(t)}\in \hat F$}
					\If{$\exists \tilde m^{(t)}\in \tilde M$ такое, что $\tilde p(f^{(t)}),\tilde m^{(t)})\in\Psi_p^m$ \textbf{and}
						\\\hspace{0.5cm}$\tilde m^{(t)}$ выполним в условиях признака $f_p$ \textbf{and} 
						\\\hspace{0.5cm}$\nexists f: f\in\tilde p^{*(t)},(\tilde p(f),\tilde m(f))\in\Psi_p^m, \tilde m$ конфликтует с $\tilde m^{(t)}$}
					\State $\tilde p^{*(t)}=\tilde p^{*(t)}\cup\{f^{(t)}\}$;
					\If{$\exists R_i^j$ такой, что $f^{(t)}\in F_i^j$}
					\State $R_i^{j(t)}:=R_i^j$;
					\algstore{store5}
				\end{algorithmic}
			\end{algorithm}
		}
	\end{frame}
	
	\begin{frame}[t]
		\frametitle{Алгоритм $\mathfrak{A}_{pm}$ доопределения функции $\Psi_p^m$}
		\only<1>{
			\begin{algorithm}[H]
				\caption*{Алгоритм $\mathfrak{A}_{pm}$ (часть II)}
				\begin{algorithmic}[1]
					\algrestore*{store5}
					\Else
					\State $R_i^{j(t)}:=\argmax\limits_{\{R\}} (F_i^j\cap\tilde p^{(t)}), R_i^{j(t)}:=F_i^{j(t)}\cup f^{(t)}$;
					\EndIf
					\algstore*{store6}
				\end{algorithmic}
			\end{algorithm}
		}
		\only<2>{
			\begin{algorithm}[H]
				\caption*{Алгоритм $\mathfrak{A}_{pm}$ (часть II)}
				\begin{algorithmic}[1]
					\algrestore*{store5}
					\Else
					\State $R_i^{j(t)}:=\argmax\limits_{\{R\}} (F_i^j\cap\tilde p^{(t)}), R_i^{j(t)}:=F_i^{j(t)}\cup f^{(t)}$;																\EndIf
					\State $\bar z_s:=(z_{s1},z_{s2},\dots,z_{sq}), z_{sk}=1$, если $k$ -- индекс признака $f^{(t)}$ во входном векторе распознающего блока $R_i^{j(t)}$ и $z_{sk}=0$ иначе;
					\algstore*{store7}
				\end{algorithmic}
			\end{algorithm}
		}
		\only<3>{
			\begin{algorithm}[H]
				\caption*{Алгоритм $\mathfrak{A}_{pm}$ (часть II)}
				\begin{algorithmic}[1]
					\algrestore*{store5}
					\Else
					\State $R_i^{j(t)}:=\argmax\limits_{\{R\}} (F_i^j\cap\tilde p^{(t)}), R_i^{j(t)}:=F_i^{j(t)}\cup f^{(t)}$;
					\EndIf
					\State $\bar z_s:=(z_{s1},z_{s2},\dots,z_{sq}), z_{sk}=1$, если $k$ -- индекс признака $f^{(t)}$ во входном векторе распознающего блока $R_i^{j(t)}$ и $z_{sk}=0$ иначе;
					\State $Z^{*(t)}:=Z^{*(t)}\cup\bar z_s$;
					\algstore*{store8}
				\end{algorithmic}
			\end{algorithm}
		}
		\only<4>{
			\begin{algorithm}[H]
				\caption*{Алгоритм $\mathfrak{A}_{pm}$ (часть II)}
				\begin{algorithmic}[1]
					\algrestore{store5}
					\Else
					\State $R_i^{j(t)}:=\argmax\limits_{\{R\}} (F_i^j\cap\tilde p^{(t)}), R_i^{j(t)}:=F_i^{j(t)}\cup f^{(t)}$;
					\EndIf
					\State $\bar z_s:=(z_{s1},z_{s2},\dots,z_{sq}), z_{sk}=1$, если $k$ -- индекс признака $f^{(t)}$ во входном векторе распознающего блока $R_i^{j(t)}$ и $z_{sk}=0$ иначе;
					\State $Z^{*(t)}:=Z^{*(t)}\cup\bar z_s$;
					\State $Z_p^{(t)}:=(\bar z_1^{c(t)},\bar z_2^{e(t)},\dots,\bar z_{2\cdot k-1}^{c(t)},\bar z_{2\cdot k}^{e(t)})$, где 
					\\\hspace{1.5cm} $\bar z_i^{c(t)}=\bigvee\limits_{\tilde m_j^{(t)}}(\bar z_j^{c(t)}\rightarrow F_p^j), \bar z_i^{e(t)}=\bigvee\limits_{\tilde m_j^{(t)}}(\bar z_j^{e(t)}\Rightarrow\bar z_j^e)$;
					\EndIf
					\algstore{store9}
				\end{algorithmic}
			\end{algorithm}
		}
	\end{frame}
	
	\begin{frame}[t]
		\frametitle{Алгоритм $\mathfrak{A}_{pm}$ доопределения функции $\Psi_p^m$}
		\only<1>{
			\begin{algorithm}[H]
				\caption*{Алгоритм $\mathfrak{A}_{pm}$ (часть III)}
				\begin{algorithmic}[1]
					\algrestore*{store9}
					\State $\tilde m^{*(t)}=\{f_p^{(t)}\}$;
					\State $\mathcal Z^{*(t)}=\{Z^{*(t)}\}$;
					\State $t=t+1$;
					\EndFor
					\algstore*{store10}
				\end{algorithmic}
			\end{algorithm}
		}
		\only<2>{
			\begin{algorithm}[H]
				\caption*{Алгоритм $\mathfrak{A}_{pm}$ (часть III)}
				\begin{algorithmic}[1]
					\algrestore{store9}
					\State $\tilde m^{*(t)}=\{f_p^{(t)}\}$;
					\State $\mathcal Z^{*(t)}=\{Z^{*(t)}\}$;
					\State $t=t+1$;
					\EndFor
					
					\Return $\Psi_p^m$, определённая на паре $(\tilde p, \tilde m)$, где $\tilde p=\lim\limits_{t\rightarrow\infty}\tilde p^{*(t)}$, 
					\\\hspace{1.0cm}$f^*, Z^*=\lim\limits_{t\rightarrow\infty}Z^{*(t)},\mathcal Z^*=\{Z^*\}$;
				\end{algorithmic}
			\end{algorithm}
		}
	\end{frame}	
	
	\begin{frame}
		\frametitle{Теорема корректности алгоритма $\mathfrak A_{pm}$}
		\begin{Theorem}[А.\,И.~Панов]
			Алгоритм $\mathfrak A_{pm}$ корректен, т.~е. последовательность функциональных значений $\langle\tilde m^{*(0)},\tilde m^{*(1)},\dots\rangle$, которая строится с помощью алгоритма $\mathfrak A_{pm}$ для функционального значения $\tilde m$, сходится к $\tilde m$.
		\end{Theorem}
	\end{frame}
	
	\begin{frame}
		\frametitle{Результаты}
		\begin{enumerate}
			\item Построена модель компонент знака "--- элемента картины мира субъекта деятельности.
			\item Построены четыре типа операторов распознавания (два статических случая, динамический и иерархический случаи) в терминах алгебраической теории для образной компоненты знака.
			\item Доказаны теоремы корректности линейных замыканий множеств построенных в работе операторов распознавания.
			\item Построен алгоритм итерационного процесса формирования и связывания двух компонент знака.
			\item Исследована сходимость итерационного процесса формирования и связывания двух компонент знака.
		\end{enumerate}
	\end{frame}
			
	\begin{frame}
		\centering
		\Huge
		Спасибо за внимание!
		\normalsize
		\par\bigskip
		\par\bigskip
		ИСА РАН, лаб. <<Динамические интеллектуальные системы>>, pan@isa.ru
	\end{frame}
\end{document}